<!DOCTYPE html>
<html>
<head>

<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
<script type="text/javascript" src="js/html5slider.js"></script>
<script type="text/javascript" src="js/paperfold.js"></script>
<script type="text/javascript" src="js/ui.js"></script>


<style>
  .hidden {
    /*overflow: hidden; important for big folds but bad for demo because it cuts of the depth in other perspectives */
    transform-style: preserve-3d;
}

/* 
    every fold is holding two identical divs: top and bottom 
    the children divs are positioned relative to it
    the slice grows from zero to 1/n of the elements height (n = number of slices)
*/

/* 
    easing functions
    ================
    
    kappa = 0.5522847498307936
    - half circle (low): cubic-bezier(0.552, 0.000, 1.000, 0.448)
    - half circle (top): cubic-bezier(0.000, 0.552, 0.448, 1.000) 
    - ease cubic-bezier(0.250, 0.100, 0.250, 1.000)
    - inverse-ease cubic-bezier(0.750, 0.000, 0.750, 0.900) 
    
    - self tested cubic-bezier(0.500, 0.200, 0.900, 0.820)
*/

.showHelpers .hidden .fold {
    outline: 1px solid rgba(255, 0, 0, .13);
    background: rgba(255, 0, 0, .13);
}
.showHelpers .hidden .fold .inner {
    outline: 1px solid rgba(0, 255, 0, .13);
    background: rgba(0, 255, 0, .13);
}
.showHelpers .hidden .fold .top,
.showHelpers .hidden .fold .bottom {
    overflow: visible;
}
.showHelpers .hidden .fold .top:after,
.showHelpers .hidden .fold .bottom:after {
    content: "";
    height: 100%;
    width: 100%;
    background-color: rgba(0,0,0,.34);
    position: absolute;
}

.hidden .fold {
    height: 0;
    position: relative;
    transform-style: preserve-3d;
    perspective: 1000px;
}

.hidden.ready .fold {
    transition: height 500ms linear;
}

/* reset the background color */
.hidden .fold section { background: none; }
/* 
    they are the two folds - top and bottom
*/
.hidden .fold .top,
.hidden .fold .bottom {
    width: 502px;
    transform-origin: top;
    transform: rotateX(-90deg);
    background-image: linear-gradient(top, rgba(255,255,255,0.5), rgba(255,255,255,0.55) 3%, rgba(255,255,255,0.5) 66%, rgba(255,255,255,0));
    background-color: #505455; /* hsl(192,6,33) */
    position: relative;
    overflow: hidden;
}

.hidden.ready .fold .top,
.hidden.ready .fold .bottom {
    /* closing transition */
    transition: transform 500ms cubic-bezier(0.000, 0.450, 1.000, 0.950), background-color 500ms ease-in;
}

.hidden .fold .bottom {
    bottom: 0;
    position: absolute;
    background-image: linear-gradient(top, rgba(255,255,255,0), rgba(255,255,255,0.5) 34%, rgba(255,255,255,.95) 97%, rgba(255,255,255,1));
    transform-origin: bottom;
    transform: rotateX(90deg);
}

.hidden.visible .fold .top,
.hidden.visible .fold .bottom {
    transform: rotateX(0);
    background-color: white;
    /* opening transition */
    transition: transform 500ms cubic-bezier(0.000, 0.050, 1.000, 0.550), background-color 500ms ease-out;
}

/* inner holder for the content */
.hidden .fold .inner {
    position: absolute;
}

.seeMore {
    padding: 0;
    height: 23px;
    width: 500px;
    color: gray;
    text-align: center;
    background: repeating-linear-gradient(
        white, #ecefef 5px, #ccc 5px, #ccc 6px
    );
    border: 1px solid rgba(0,0,0,0.13);
    border-bottom: none;
    box-shadow: 0 -1px rgba(0,0,0,.16) inset;
    overflow: hidden;
    cursor: pointer;
    transition: 500ms;
}
.visible + .seeMore { 
    margin-bottom: -25px;
    border-top-color: white;
    border-bottom-color: white;
}

.seeMore > span {
    font-size: 11px;
    line-height: 29px;
    padding: 5px 8px;
    background: white;
    border-radius: 2px 2px 0 0;
    box-shadow: 0 1px 2px rgba(0,0,0,.75), 0 1px white;
}


.hidden.ready, .hidden.ready.visible,
.hidden.ready .fold, .hidden.ready.visible .fold,
.hidden.ready .fold .top, .hidden.ready .fold .bottom,
.hidden.ready.visible .fold .top, .hidden.ready.visible .fold .bottom,
.hidden.ready .fold .inner,
.buddycloud .seeMore {
    transition-duration: 400ms;
}

.hidden.no-transition, .hidden.visible.no-transition,
.hidden.no-transition .fold, .hidden.visible.no-transition .fold,
.hidden.no-transition .fold .top, .hidden.no-transition .fold .bottom,
.hidden.visible.no-transition .fold .top, .hidden.visible.no-transition .fold .bottom,
.hidden.no-transition .fold .inner,
.buddycloud .visible.no-transition + .seeMore {
    transition: none;
}
</style>


</head>
<body>


<!DOCTYPE html>
<html lang="en">
<!--
      Copyright (c) 2011 Felix Niklas
      This script is freely distributable under the terms of the MIT license.
-->
<head>
  <meta charset="utf-8" />
  <title>Paperfold CSS</title>
  <link href="css/style.css" rel="stylesheet" />
  <link href="css/buddycloud.css" rel="stylesheet" />
  <link href="css/paperfold.css" rel="stylesheet" />
  <script type="text/javascript" src="js/modernizr.custom.71147.js"></script>
  <script type="text/javascript" src="js/prefixfree.min.js"></script>
</head>
<body>
  <div id="controls">
    <h1>Paperfold CSS</h1>
    <button id="go" class="highlighted">Open</button>
    <h2>Settings</h2>
    <div>
      <label for="time" class="hasOutput">Time <span id="showTime">0</span></label>
      <input id="time" type="range" min="0" max="100" step="1" value="0" />
    </div>
    <div>
      <label for="foldHeight" class="hasOutput">Height Limit<span id="showFoldHeight">200</span></label>
      <input id="foldHeight" type="range" min="20" max="400" step="1" value="200" />
    </div>
    <div>
      <label for="perspective" class="hasOutput">3D Perspective<span id="showPerspective">1000</span></label>
      <input id="perspective" type="range" min="500" max="4000" step="1" value="1000" />
    </div>
    <div>
      <label for="showHelpers">Show Helpers</label>
      <input type="checkbox" id="showHelpers" />
    </div>
    <div>
      <p>Hint: drag to see the effect in 3D space</p>
    </div>
  </div>
  <div class="playground">
    <div class="box buddycloud">
      <h1>Buddycloud</h1>
      <div class="stream">
        <article class="topic">
          <section class="opener">
            <div class="avatar user2"></div>
            <div class="postmeta">
              <span class="time">3 days</span>
            </div>
            <span class="name">Vera</span><span class="location">from Campus Library</span>
            <p>Pretend. You pretend the feelings are there, for the world, for the people around you.</p>
          </section>
          <div class="hidden">
            <section class="comment">
              <div class="avatar user6"></div>
              <div class="postmeta">
                <span class="time">3 days</span>
              </div>
              <span class="name">Mona</span><span class="location">from Cafe Extra</span>
              <p>Who knows? Maybe one day they will be. I like seafood.</p>
            </section>
            <section class="comment">
              <div class="avatar user7"></div>
              <div class="postmeta">
                <span class="time">3 days</span>
              </div>
              <span class="name">Verena</span><span class="location">from Home</span>
              <p>Finding a needle in a haystack isn't hard when every straw is computerized. I'm really more an apartment person.</p>
            </section>
            <section class="comment">
              <div class="avatar user12"></div>
              <div class="postmeta">
                <span class="time">3 days</span>
              </div>
              <span class="name">Sebastian</span><span class="location">from Passau</span>
              <p>I feel like a jigsaw puzzle missing a piece. And I'm not even sure what the picture should be.</p>
            </section>
            <section class="comment">
              <div class="avatar user3"></div>
              <div class="postmeta">
                <span class="time">3 days</span>
              </div>
              <span class="name">Tom</span><span class="location">from Island</span>
              <p>Who knows? Maybe one day they will be. I like seafood.</p>
            </section>
            <section class="comment">
              <div class="avatar user2"></div>
              <div class="postmeta">
                <span class="time">3 days</span>
              </div>
              <span class="name">Vera</span><span class="location">from Munich</span>
              <p>Finding a needle in a haystack isn't hard when every straw is computerized. I'm really more an apartment person.</p>
            </section>
          </div><!-- /hidden -->
          <section class="seeMore">
            <span>See <span>5</span> More Posts</span>
          </section>
          <section class="comment">
            <div class="avatar user5"></div>
            <div class="postmeta">
              <span class="time">3 days</span>
            </div>
            <span class="name">Gero</span><span class="location">from Regensburg</span>
            <p>I feel like a jigsaw puzzle missing a piece. And I'm not even sure what the picture should be.</p>
          </section>
          <section class="comment">
            <div class="avatar user11"></div>
            <div class="postmeta">
              <span class="time">3 days</span>
            </div>
            <span class="name">Betty</span><span class="location">from Deggendorf</span>
            <p>I'm going to tell you something that I've never told anyone before.</p>
          </section>
          <section class="answer">
            <div class="avatar user1"></div>
            <textarea placeholder="post a comment..."></textarea>
            <div class="controls">
              <div class="button small prominent">Post</div>
            </div>
          </section>
        </article>
        <article class="topic">
          <section class="opener">
            <div class="avatar user2"></div>
            <div class="postmeta">
              <span class="time" title="5:06pm 06.06.2011">5 days</span>
            </div>
            <span class="name">Vera</span><span class="location">from Home</span>
            <p>
              Night time - sympathize - I've been working on white lies.
              So I'll tell the truth - I'll give it up to you.
              And when the day come, it will have all been fun. We'll talk about it soon.
            </p>
          </section>
          <section class="answer">
            <div class="avatar user1"></div>
            <textarea placeholder="post a comment..."></textarea>
            <div class="controls">
              <div class="button small prominent">Post</div>
            </div>
          </section>
        </article>
      </div>
    </div>
  </div>

<script>
var paperfolds = [];          
var hiddenElements = $('.hidden');
var transEndEventNames = {
    'WebkitTransition' : 'webkitTransitionEnd',
    'MozTransition'    : 'transitionend',
    'OTransition'      : 'oTransitionEnd',
    'msTransition'     : 'MSTransitionEnd',
    'transition'       : 'transitionend'
},
transEndEventName = transEndEventNames[ Modernizr.prefixed('transition') ];

var paperfold = {
    percentage: 0,
    timeVirgin: true,
    init: function(element, maxHeight, toggleCallback){
      this.element = $(element);
      this.maxHeight = maxHeight;
      this.toggleCallback = toggleCallback;
      
      // get real element height
      this.height = this.element.css('height', 'auto').height();
      this.element.css('height', '');
      
      // calculate amount and height of the folds
      this.foldCount = Math.ceil(this.height / this.maxHeight);
      this.foldHeight = Math.floor(this.height / this.foldCount);
      
      // detach the elements children from the dom and cache them 
      this.content = this.element.children().detach();
      
      // add folds containing the previously cached children elements
      // to the element
      for(var i=0, j=0; i<this.foldCount; i++, j+=2){
        var topHeight = bottomHeight = Math.floor(this.foldHeight/2);
        if( (i+1) === this.foldCount && this.foldHeight/2 % 2 ) bottomHeight = this.height-(j+1)*topHeight;
        this.element.append( this.createFold(j, topHeight, bottomHeight) );
      }
      
      // cache the folds -> can i do this while creating them?
      // i mean i can of course cache them but then the dom connection is not there
      // i'd love to get a hint: @mrflix or mrflix@gmail.com
      this.folds = this.element.find('> .fold');
      this.bottoms = this.folds.find('> .bottom');
      this.tops = this.folds.find('> .top');
      
      // bind buttons
      this.element.next('.seeMore').click( $.proxy(this, 'toggle') );
      $('#go').click( $.proxy(this, 'toggle') );
      
      this.element.addClass('ready');
    },
    update: function(maxHeight){
      this.element.children().detach();
      this.element.html(this.content);
      this.init(this.element, maxHeight);
      if(this.percentage !== 0){
        this.open(this.percentage);
      }
    },
    createFold: function(j, topHeight, bottomHeight){
      var offsetTop = -j*topHeight;
      var offsetBottom = -this.height+j*topHeight+this.foldHeight;
      return $('<div>').addClass('fold').append(
              $('<div>').addClass('top').css('height', topHeight).append(
                $('<div>').addClass('inner').css('top', offsetTop).append(this.content.clone())
              ).add($('<div>').addClass('bottom').css('height', bottomHeight).append(
                $('<div>').addClass('inner').css('bottom', offsetBottom).append(this.content.clone())
              ))
            );
    },
    toggle: function(){
      this.element.toggleClass('visible');
      if(this.element.hasClass('visible')){
        // open
        // animate folds height (css transition)
        this.folds.height(this.foldHeight);
        
        // if the time slider was already used, reset the folds
        if(!this.timeVirigin) this.open(1);  
        
        // change button text
        $('#go').text('Close');
        
        // adapt time slider
        $(clock).animate({ time : 100 }, { duration : 400, step : function(now){
          $('#time').val(now);
        }});
      } else {
        // close
        // animate folds height (css transition)
        this.folds.height(0);
        
        // if the time slider was already used, reset the folds
        if(!this.timeVirigin) this.open(0);
        
        // change button text
        $('#go').text('Open');
        
        // adapt time slider
        $(clock).animate({ time : 0 }, { duration : 400, step : function(now){
          $('#time').val(now);
        }});
      }  
      this.tops.add(this.bottoms).css('background-color', '').css(transformString, '');
    },
    open: function(percentage){
      // cache percentage
      this.percentage = percentage;
      //clock.time = percentage * 100;
      timeVirigin = false;
      
      // change angle of tops and bottoms
      var c = this.foldHeight * percentage
      ,   a = b = this.foldHeight/2
      ,   part = 2*b*c
      ,   bottomAngle = part <= 0 ? 90 : Math.acos( (b*b+c*c-a*a) / part )*180/Math.PI
      ,   topAngle = 360-bottomAngle;
      
      this.tops.css(transformString, 'rotateX(' + topAngle + 'deg)');
      this.bottoms.css(transformString, 'rotateX(' + bottomAngle + 'deg)');
      
      // change folds height
      var foldHeight = this.height/this.foldCount * percentage;
      this.folds.height(foldHeight);
      
      // change the background color
      // from dark hsl(192,6,33) at 0
      // to light hsl(192,0,100) at 100
      var saturation = Math.round(6 - 6 * percentage)
      ,   lightness = 33 + Math.round(67 * percentage)
      ,   backgroundColor = 'hsl(192,'+saturation+'%,'+lightness+'%)';
      
      this.tops.add(this.bottoms).css('background-color', backgroundColor);
    },
};

$.each(hiddenElements, function(i, element){
    paperfolds[i] = Object.create(paperfold);
    paperfolds[i].init(element, 200);
});
</script>

<script>
  /*
html5slider - a JS implementation of <input type=range> for Firefox 4 and up
https://github.com/fryn/html5slider

Copyright (c) 2010-2011 Frank Yan, <http://frankyan.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

(function() {

// test for native support
var test = document.createElement('input');
try {
  test.type = 'range';
  if (test.type == 'range')
    return;
} catch (e) {
  return;
}

// test for required property support
if (!document.mozSetImageElement || !('MozAppearance' in test.style))
  return;

var scale;
var isMac = navigator.platform == 'MacIntel';
var thumb = {
  radius: isMac ? 9 : 6,
  width: isMac ? 22 : 12,
  height: isMac ? 16 : 20
};
var track = 'transparent';
var styles = {
  padding: 0,
  cursor: 'default',
  'font': '0/0 a',
  'color': 'transparent',
  'text-shadow': 'none'
};
var onChange = document.createEvent('HTMLEvents');
onChange.initEvent('change', true, false);

if (document.readyState == 'loading')
  document.addEventListener('DOMContentLoaded', initialize, true);
else
  initialize();

function initialize() {
  // create initial sliders
  Array.forEach(document.querySelectorAll('input[type=range]'), transform);
  // create sliders on-the-fly
  document.addEventListener('DOMNodeInserted', onNodeInserted, true);
}

function onNodeInserted(e) {
  check(e.target);
  if (e.target.querySelectorAll)
    Array.forEach(e.target.querySelectorAll('input'), check);
}

function check(input, async) {
  if (input.localName != 'input' || input.type == 'range');
  else if (input.getAttribute('type') == 'range')
    transform(input);
  else if (!async)
    setTimeout(check, 0, input, true);
}

function transform(slider) {

  var isValueSet, areAttrsSet, isChanged, isClick, prevValue, rawValue, prevX;
  var min, max, step, range, value = slider.value;

  // lazily create shared slider affordance
  if (!scale) {
    scale = document.body.appendChild(document.createElement('hr'));
    style(scale, {
      '-moz-appearance': isMac ? 'scale-horizontal' : 'scalethumb-horizontal',
      display: 'block',
      visibility: 'visible',
      opacity: 1,
      position: 'fixed',
      top: '-999999px'
    });
    document.mozSetImageElement('__sliderthumb__', scale);
  }

  // reimplement value and type properties
  var getValue = function() { return '' + value; };
  var setValue = function setValue(val) {
    value = '' + val;
    isValueSet = true;
    draw();
    delete slider.value;
    slider.value = value;
    slider.__defineGetter__('value', getValue);
    slider.__defineSetter__('value', setValue);
  };
  slider.__defineGetter__('value', getValue);
  slider.__defineSetter__('value', setValue);
  slider.__defineGetter__('type', function() { return 'range'; });

  // sync properties with attributes
  ['min', 'max', 'step'].forEach(function(prop) {
    if (slider.hasAttribute(prop))
      areAttrsSet = true;
    slider.__defineGetter__(prop, function() {
      return this.hasAttribute(prop) ? this.getAttribute(prop) : '';
    });
    slider.__defineSetter__(prop, function(val) {
      val === null ? this.removeAttribute(prop) : this.setAttribute(prop, val);
    });
  });

  // initialize slider
  slider.readOnly = true;
  style(slider, styles);
  update();

  slider.addEventListener('DOMAttrModified', function(e) {
    // note that value attribute only sets initial value
    if (e.attrName == 'value' && !isValueSet) {
      value = e.newValue;
      draw();
    }
    else if (~['min', 'max', 'step'].indexOf(e.attrName)) {
      update();
      areAttrsSet = true;
    }
  }, true);

  slider.addEventListener('mousedown', onDragStart, true);
  slider.addEventListener('keydown', onKeyDown, true);
  slider.addEventListener('focus', onFocus, true);
  slider.addEventListener('blur', onBlur, true);

  function onDragStart(e) {
    isClick = true;
    setTimeout(function() { isClick = false; }, 0);
    if (e.button || !range)
      return;
    var width = parseFloat(getComputedStyle(this, 0).width);
    var multiplier = (width - thumb.width) / range;
    if (!multiplier)
      return;
    // distance between click and center of thumb
    var dev = e.clientX - this.getBoundingClientRect().left - thumb.width / 2 -
              (value - min) * multiplier;
    // if click was not on thumb, move thumb to click location
    if (Math.abs(dev) > thumb.radius) {
      isChanged = true;
      this.value -= -dev / multiplier;
    }
    rawValue = value;
    prevX = e.clientX;
    this.addEventListener('mousemove', onDrag, true);
    this.addEventListener('mouseup', onDragEnd, true);
  }

  function onDrag(e) {
    var width = parseFloat(getComputedStyle(this, 0).width);
    var multiplier = (width - thumb.width) / range;
    if (!multiplier)
      return;
    rawValue += (e.clientX - prevX) / multiplier;
    prevX = e.clientX;
    isChanged = true;
    this.value = rawValue;
  }

  function onDragEnd() {
    this.removeEventListener('mousemove', onDrag, true);
    this.removeEventListener('mouseup', onDragEnd, true);
  }

  function onKeyDown(e) {
    if (e.keyCode > 36 && e.keyCode < 41) { // 37-40: left, up, right, down
      onFocus.call(this);
      isChanged = true;
      this.value = value + (e.keyCode == 38 || e.keyCode == 39 ? step : -step);
    }
  }

  function onFocus() {
    if (!isClick)
      this.style.boxShadow = !isMac ? '0 0 0 2px #fb0' :
        '0 0 2px 1px -moz-mac-focusring, inset 0 0 1px -moz-mac-focusring';
  }

  function onBlur() {
    this.style.boxShadow = '';
  }

  // determines whether value is valid number in attribute form
  function isAttrNum(value) {
    return !isNaN(value) && +value == parseFloat(value);
  }

  // validates min, max, and step attributes and redraws
  function update() {
    min = isAttrNum(slider.min) ? +slider.min : 0;
    max = isAttrNum(slider.max) ? +slider.max : 100;
    if (max < min)
      max = min > 100 ? min : 100;
    step = isAttrNum(slider.step) && slider.step > 0 ? +slider.step : 1;
    range = max - min;
    draw(true);
  }

  // recalculates value property
  function calc() {
    if (!isValueSet && !areAttrsSet)
      value = slider.getAttribute('value');
    if (!isAttrNum(value))
      value = (min + max) / 2;;
    // snap to step intervals (WebKit sometimes does not - bug?)
    value = Math.round((value - min) / step) * step + min;
    if (value < min)
      value = min;
    else if (value > max)
      value = min + ~~(range / step) * step;
  }

  // renders slider using CSS background ;)
  function draw(attrsModified) {
    calc();
    if (isChanged && value != prevValue)
      slider.dispatchEvent(onChange);
    isChanged = false;
    if (!attrsModified && value == prevValue)
      return;
    prevValue = value;
    var position = range ? (value - min) / range * 100 : 0;
    var bg = 'url(img/sliderThumb.png) ' + position + '% 3px no-repeat, ';
    style(slider, { background: bg + track });
  }

}

function style(element, styles) {
  for (var prop in styles)
    element.style.setProperty(prop, styles[prop], 'important');
}

})();
</script>


<script>
  /*
html5slider - a JS implementation of <input type=range> for Firefox 4 and up
https://github.com/fryn/html5slider

Copyright (c) 2010-2011 Frank Yan, <http://frankyan.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

(function() {

// test for native support
var test = document.createElement('input');
try {
  test.type = 'range';
  if (test.type == 'range')
    return;
} catch (e) {
  return;
}

// test for required property support
if (!document.mozSetImageElement || !('MozAppearance' in test.style))
  return;

var scale;
var isMac = navigator.platform == 'MacIntel';
var thumb = {
  radius: isMac ? 9 : 6,
  width: isMac ? 22 : 12,
  height: isMac ? 16 : 20
};
var track = 'transparent';
var styles = {
  padding: 0,
  cursor: 'default',
  'font': '0/0 a',
  'color': 'transparent',
  'text-shadow': 'none'
};
var onChange = document.createEvent('HTMLEvents');
onChange.initEvent('change', true, false);

if (document.readyState == 'loading')
  document.addEventListener('DOMContentLoaded', initialize, true);
else
  initialize();

function initialize() {
  // create initial sliders
  Array.forEach(document.querySelectorAll('input[type=range]'), transform);
  // create sliders on-the-fly
  document.addEventListener('DOMNodeInserted', onNodeInserted, true);
}

function onNodeInserted(e) {
  check(e.target);
  if (e.target.querySelectorAll)
    Array.forEach(e.target.querySelectorAll('input'), check);
}

function check(input, async) {
  if (input.localName != 'input' || input.type == 'range');
  else if (input.getAttribute('type') == 'range')
    transform(input);
  else if (!async)
    setTimeout(check, 0, input, true);
}

function transform(slider) {

  var isValueSet, areAttrsSet, isChanged, isClick, prevValue, rawValue, prevX;
  var min, max, step, range, value = slider.value;

  // lazily create shared slider affordance
  if (!scale) {
    scale = document.body.appendChild(document.createElement('hr'));
    style(scale, {
      '-moz-appearance': isMac ? 'scale-horizontal' : 'scalethumb-horizontal',
      display: 'block',
      visibility: 'visible',
      opacity: 1,
      position: 'fixed',
      top: '-999999px'
    });
    document.mozSetImageElement('__sliderthumb__', scale);
  }

  // reimplement value and type properties
  var getValue = function() { return '' + value; };
  var setValue = function setValue(val) {
    value = '' + val;
    isValueSet = true;
    draw();
    delete slider.value;
    slider.value = value;
    slider.__defineGetter__('value', getValue);
    slider.__defineSetter__('value', setValue);
  };
  slider.__defineGetter__('value', getValue);
  slider.__defineSetter__('value', setValue);
  slider.__defineGetter__('type', function() { return 'range'; });

  // sync properties with attributes
  ['min', 'max', 'step'].forEach(function(prop) {
    if (slider.hasAttribute(prop))
      areAttrsSet = true;
    slider.__defineGetter__(prop, function() {
      return this.hasAttribute(prop) ? this.getAttribute(prop) : '';
    });
    slider.__defineSetter__(prop, function(val) {
      val === null ? this.removeAttribute(prop) : this.setAttribute(prop, val);
    });
  });

  // initialize slider
  slider.readOnly = true;
  style(slider, styles);
  update();

  slider.addEventListener('DOMAttrModified', function(e) {
    // note that value attribute only sets initial value
    if (e.attrName == 'value' && !isValueSet) {
      value = e.newValue;
      draw();
    }
    else if (~['min', 'max', 'step'].indexOf(e.attrName)) {
      update();
      areAttrsSet = true;
    }
  }, true);

  slider.addEventListener('mousedown', onDragStart, true);
  slider.addEventListener('keydown', onKeyDown, true);
  slider.addEventListener('focus', onFocus, true);
  slider.addEventListener('blur', onBlur, true);

  function onDragStart(e) {
    isClick = true;
    setTimeout(function() { isClick = false; }, 0);
    if (e.button || !range)
      return;
    var width = parseFloat(getComputedStyle(this, 0).width);
    var multiplier = (width - thumb.width) / range;
    if (!multiplier)
      return;
    // distance between click and center of thumb
    var dev = e.clientX - this.getBoundingClientRect().left - thumb.width / 2 -
              (value - min) * multiplier;
    // if click was not on thumb, move thumb to click location
    if (Math.abs(dev) > thumb.radius) {
      isChanged = true;
      this.value -= -dev / multiplier;
    }
    rawValue = value;
    prevX = e.clientX;
    this.addEventListener('mousemove', onDrag, true);
    this.addEventListener('mouseup', onDragEnd, true);
  }

  function onDrag(e) {
    var width = parseFloat(getComputedStyle(this, 0).width);
    var multiplier = (width - thumb.width) / range;
    if (!multiplier)
      return;
    rawValue += (e.clientX - prevX) / multiplier;
    prevX = e.clientX;
    isChanged = true;
    this.value = rawValue;
  }

  function onDragEnd() {
    this.removeEventListener('mousemove', onDrag, true);
    this.removeEventListener('mouseup', onDragEnd, true);
  }

  function onKeyDown(e) {
    if (e.keyCode > 36 && e.keyCode < 41) { // 37-40: left, up, right, down
      onFocus.call(this);
      isChanged = true;
      this.value = value + (e.keyCode == 38 || e.keyCode == 39 ? step : -step);
    }
  }

  function onFocus() {
    if (!isClick)
      this.style.boxShadow = !isMac ? '0 0 0 2px #fb0' :
        '0 0 2px 1px -moz-mac-focusring, inset 0 0 1px -moz-mac-focusring';
  }

  function onBlur() {
    this.style.boxShadow = '';
  }

  // determines whether value is valid number in attribute form
  function isAttrNum(value) {
    return !isNaN(value) && +value == parseFloat(value);
  }

  // validates min, max, and step attributes and redraws
  function update() {
    min = isAttrNum(slider.min) ? +slider.min : 0;
    max = isAttrNum(slider.max) ? +slider.max : 100;
    if (max < min)
      max = min > 100 ? min : 100;
    step = isAttrNum(slider.step) && slider.step > 0 ? +slider.step : 1;
    range = max - min;
    draw(true);
  }

  // recalculates value property
  function calc() {
    if (!isValueSet && !areAttrsSet)
      value = slider.getAttribute('value');
    if (!isAttrNum(value))
      value = (min + max) / 2;;
    // snap to step intervals (WebKit sometimes does not - bug?)
    value = Math.round((value - min) / step) * step + min;
    if (value < min)
      value = min;
    else if (value > max)
      value = min + ~~(range / step) * step;
  }

  // renders slider using CSS background ;)
  function draw(attrsModified) {
    calc();
    if (isChanged && value != prevValue)
      slider.dispatchEvent(onChange);
    isChanged = false;
    if (!attrsModified && value == prevValue)
      return;
    prevValue = value;
    var position = range ? (value - min) / range * 100 : 0;
    var bg = 'url(img/sliderThumb.png) ' + position + '% 3px no-repeat, ';
    style(slider, { background: bg + track });
  }

}

function style(element, styles) {
  for (var prop in styles)
    element.style.setProperty(prop, styles[prop], 'important');
}

})();
</script>

<script>
  
</script>

</body>
</html>


</body>
</html>
